<?php 

//BRNRDPROJECT-REDBEAN - SOURCE CODE

/**

--- welcome to

                   .______.                         
_______   ____   __| _/\_ |__   ____ _____    ____  
\_  __ \_/ __ \ / __ |  | __ \_/ __ \\__  \  /    \ 
 |  | \/\  ___// /_/ |  | \_\ \  ___/ / __ \|   |  \
 |__|    \___  >____ |  |___  /\___  >____  /___|  /
             \/     \/      \/     \/     \/     \/ 



|RedBean Database Objects -
|Written by Gabor de Mooij (c) copyright 2009


|List of Contributors:
|Sean Hess 
|Alan Hogan
|Desfrenes

======================================================
|						       RedBean is Licensed BSD
------------------------------------------------------
|RedBean is a OOP Database Simulation Middleware layer
|for php.
------------------------------------------------------
|Loosely based on an idea by Erik Roelofs - thanks man

VERSION 0.5

======================================================
Official GIT HUB:
git://github.com/buurtnerd/redbean.git
http://github.com/buurtnerd/redbean/tree/master
======================================================



Copyright (c) 2009, G.J.G.T (Gabor) de Mooij
All rights reserved.

a Buurtnerd project


Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
* Neither the name of the <organization> nor the
names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.

All advertising materials mentioning features or use of this software
are encouraged to display the following acknowledgement:
This product is powered by RedBean written by Gabor de Mooij (http://www.redbeanphp.com)


----




THIS SOFTWARE IS PROVIDED BY GABOR DE MOOIJ ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL GABOR DE MOOIJ BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



WARNING
THIS IS AN PRE-BETA VERSION, DONT USE THIS CODE ON PRODUCTION SERVERS

*/

class RedBean_Can implements Iterator , ArrayAccess , SeekableIterator , Countable { private $collectionIDs = null; private $type = null; private $pointer = 0; private $num = 0; public function __construct( $type="", $collection = array() ) { $this->collectionIDs = $collection; $this->type = $type; $this->num = count( $this->collectionIDs ); } public function wrap( $bean ) { $dclass = PRFX.$this->type.SFFX; $deco = new $dclass( floatval( $bean->id ) ); $deco->setData( $bean ); return $deco; } public function count() { return $this->num; } public function getBeans() { $rows = RedBean_OODB::fastloader( $this->type, $this->collectionIDs ); $beans = array(); if (is_array($rows)) { foreach( $rows as $row ) { $beans[] = $this->wrap( RedBean_OODB::getById( $this->type, $row["id"] , $row) ); } } return $beans; } public function slice( $begin=0, $end=0 ) { $this->collectionIDs = array_slice( $this->collectionIDs, $begin, $end); $this->num = count( $this->collectionIDs ); } public function current() { if (isset($this->collectionIDs[$this->pointer])) { $id = $this->collectionIDs[$this->pointer]; return $this->wrap( RedBean_OODB::getById( $this->type, $id ) ); } else { return null; } } public function key() { return $this->pointer; } public function next() { return ++$this->pointer; } public function prev() { if ($this->pointer > 0) { return ++$this->pointer; }else { return 0; } } public function rewind() { $this->pointer=0; return 0; } public function seek( $seek ) { $this->pointer = (int) $seek; } public function valid() { return ($this->num > ($this->pointer+1)); } public function hasMoreBeans() { return $this->valid(); } public function offsetSet($offset, $value) { $this->collectionIDs[$offset] = $value; } public function offsetExists($offset) { return isset($this->collectionIDs[$offset]); } public function offsetUnset($offset) { unset($this->collectionIDs[$offset]); } public function offsetGet($offset) { if (isset($this->collectionIDs[$offset])) { $id = $this->collectionIDs[$offset]; return $this->wrap( RedBean_OODB::getById( $this->type, $id ) ); } else { return null; } } public function getList() { $list = array(); $beans = $this->getBeans(); foreach($beans as $bean) { $list[] = $bean->exportAsArr(); } return $list; } public function reverse() { $this->collectionIDs = array_reverse($this->collectionIDs, true); return $this; } }
class RedBean_DBAdapter extends RedBean_Observable { private $db = null; private $sql = ""; public function __construct($database) { $this->db = $database; } public function getSQL() { return $this->sql; } public function escape( $sqlvalue ) { return $this->db->Escape($sqlvalue); } public function exec( $sql , $noevent=false) { if (!$noevent){ $this->sql = $sql; $this->signal("sql_exec", $this); } return $this->db->Execute( $sql ); } public function get( $sql ) { $this->sql = $sql; $this->signal("sql_exec", $this); return $this->db->GetAll( $sql ); } public function getRow( $sql ) { $this->sql = $sql; $this->signal("sql_exec", $this); return $this->db->GetRow( $sql ); } public function getCol( $sql ) { $this->sql = $sql; $this->signal("sql_exec", $this); return $this->db->GetCol( $sql ); } public function getCell( $sql ) { $this->sql = $sql; $this->signal("sql_exec", $this); $arr = $this->db->GetCol( $sql ); if ($arr && is_array($arr)) return ($arr[0]); else return false; } public function getInsertID() { return $this->db->getInsertID(); } public function getAffectedRows() { return $this->db->Affected_Rows(); } public function getDatabase() { return $this->db; } public function getErrorMsg() { return $this->db->Errormsg(); } }
class RedBean_Decorator extends RedBean_Observable implements IteratorAggregate { protected $data = null; protected $type = ""; protected $problems = array(); public function __construct( $type=false, $id=0, $lock=false ) { $id = floatval( $id ); if (!$type) { throw new Exception("Undefined bean type"); } else { $this->type = preg_replace( "[\W_]","", strtolower($type)); if ($id > 0) { $this->data = RedBean_OODB::getById( $this->type, $id, $lock ); } else { $this->data = RedBean_OODB::dispense( $this->type ); } } } public function free( $property ) { $this->signal("deco_free", $this); RedBean_OODB::dropColumn( $this->type, $property ); } public function importFromPost( $selection=null ) { $this->signal("deco_importpost", $this); if (!$selection) { $selection = array_keys($_POST); } if (is_string($selection)) { $selection = explode(",",$selection); } if ($selection && is_array($selection) && count($selection) > 0) { foreach( $selection as $field ) { $setter = "set".ucfirst( $field ); if (isset( $_POST[$field] )) { $resp = $this->$setter( $_POST[ $field ] ); } } } return $this; } public function import( $arr ) { $this->signal("deco_import", $this); foreach( $arr as $key=>$val ) { $setter = "set".ucfirst( $key ); $resp = $this->$setter( $val ); } return $this; } public function __call( $method, $arguments ) { return $this->command( $method, $arguments ); } public function __get( $name ) { $this->signal("deco_get", $this); $name = strtolower( $name ); return isset($this->data->$name) ? $this->data->$name : null; } public function __set( $name, $value ) { $this->signal("deco_set", $this); $name = strtolower( $name ); $this->data->$name = $value; } public function command( $method, $arguments ) { if (strpos( $method,"set" ) === 0) { $prop = substr( $method, 3 ); $this->$prop = $arguments[0]; return $this; } elseif (strpos($method,"getRelated")===0) { $this->signal("deco_get", $this); $prop = strtolower( substr( $method, 10 ) ); $beans = RedBean_OODB::getAssoc( $this->data, $prop ); $decos = array(); $dclass = PRFX.$prop.SFFX; if ($beans && is_array($beans)) { foreach($beans as $b) { $d = new $dclass(); $d->setData( $b ); $decos[] = $d; } } return $decos; } elseif (strpos( $method, "get" ) === 0) { $prop = substr( $method, 3 ); return $this->$prop; } elseif (strpos( $method, "is" ) === 0) { $prop = strtolower( substr( $method, 2 ) ); if (!isset($this->data->$prop)) { $this->signal("deco_get",$this); return false; } return ($this->data->$prop ? TRUE : FALSE); } else if (strpos($method,"add") === 0) { $this->signal("deco_add",$this); $deco = $arguments[0]; $bean = $deco->getData(); RedBean_OODB::associate($this->data, $bean); return $this; } else if (strpos($method,"remove")===0) { $this->signal("deco_remove",$this); $deco = $arguments[0]; $bean = $deco->getData(); RedBean_OODB::unassociate($this->data, $bean); return $this; } else if (strpos($method,"attach")===0) { $this->signal("deco_attach",$this); $deco = $arguments[0]; $bean = $deco->getData(); RedBean_OODB::addChild($this->data, $bean); return $this; } else if (strpos($method,"clearRelated")===0) { $this->signal("deco_clearrelated",$this); $type = strtolower( substr( $method, 12 ) ); RedBean_OODB::deleteAllAssocType($type, $this->data); return $this; } else if (strpos($method,"numof")===0) { $this->signal("deco_numof",$this); $type = strtolower( substr( $method, 5 ) ); return RedBean_OODB::numOfRelated($type, $this->data); } } public function belongsTo( $deco ) { $this->signal("deco_belongsto", $this); RedBean_OODB::deleteAllAssocType($deco->getType(), $this->data); RedBean_OODB::associate($this->data, $deco->getData()); } public function exclusiveAdd( $deco ) { $this->signal("deco_exclusiveadd", $this); RedBean_OODB::deleteAllAssocType($this->type,$deco->getData()); RedBean_OODB::associate($deco->getData(), $this->data); } public function parent() { $this->signal("deco_parent", $this); $beans = RedBean_OODB::getParent( $this->data ); if (count($beans) > 0 ) $bean = array_pop($beans); else return null; $dclass = PRFX.$this->type.SFFX; $deco = new $dclass(); $deco->setData( $bean ); return $deco; } public function siblings() { $this->signal("deco_siblings", $this); $beans = RedBean_OODB::getParent( $this->data ); if (count($beans) > 0 ) { $bean = array_pop($beans); } else { return null; } $beans = RedBean_OODB::getChildren( $bean ); $decos = array(); $dclass = PRFX.$this->type.SFFX; if ($beans && is_array($beans)) { foreach($beans as $b) { if ($b->id != $this->data->id) { $d = new $dclass(); $d->setData( $b ); $decos[] = $d; } } } return $decos; } public function children() { $this->signal("deco_children", $this); $beans = RedBean_OODB::getChildren( $this->data ); $decos = array(); $dclass = PRFX.$this->type.SFFX; if ($beans && is_array($beans)) { foreach($beans as $b) { $d = new $dclass(); $d->setData( $b ); $decos[] = $d; } } return $decos; } public function hasParent( $deco ) { $me = $this; while( $parent = $me->parent() ) { if ($deco->getID() == $parent->getID()) { return true; } else { $me = $parent; } } return false; } public function hasChild( $deco ) { $nodes = array($this); while($node = array_shift($nodes)) { if ($node->getID() == $deco->getID() && ($node->getID() != $this->getID())) { return true; } if ($children = $node->children()) { $nodes = array_merge($nodes, $children); } } return false; } public function hasSibling( $deco ) { $siblings = $this->siblings(); foreach( $siblings as $sibling ) { if ($sibling->getID() == $deco->getID()) { return true; } } return false; } public function copy() { $this->signal("deco_copy", $this); $clone = new self( $this->type, 0 ); $clone->setData( $this->getData() ); return $clone; } public function clearAllRelations() { $this->signal("deco_clearrelations", $this); RedBean_OODB::deleteAllAssoc( $this->getData() ); } public function getData() { return $this->data; } public function setData( $data ) { $this->data = $data; } public function save() { $this->signal("deco_save", $this); return RedBean_OODB::set( $this->data ); } public static function delete( $deco ) { RedBean_OODB::trash( $deco->getData() ); } public function lock() { RedBean_OODB::openBean($this->getData()); } public function unlock() { RedBean_OODB::closeBean( $this->getData()); } public static function close( $deco ) { RedBean_OODB::closeBean( $deco->getData() ); } public static function make( $type="", $id ){ return new RedBean_Decorator( $type, $id ); } public function exportTo( &$bean, $overridebean=false ) { foreach($this->data as $prop=>$value) { if (is_object($overridebean) && isset($overridebean->$prop)) { $value = $overridebean->$prop; } elseif (is_array($overridebean) && isset($overridebean[$prop])) { $value = $overridebean[$prop]; } if (is_object($value)){ $value = $value->getID(); } if (is_object($bean)) { $bean->$prop = $value; } elseif (is_array($bean)) { $bean[$prop] = $value; } } return $bean; } public function exportAsArr() { $arr = array(); foreach($this->data as $prop=>$value) { if ($value instanceof RedBean_Decorator){ $value = $value->getID(); } $arr[ $prop ] = $value; } return $arr; } public static function find( $deco, $filter, $start=0, $end=100, $orderby=" id ASC ", $extraSQL=false ) { if (!is_array($filter)) { return array(); } if (count($filter)<1) { return array(); } $filters = array(); foreach($filter as $key=>$f) { $filters[strtolower($key)] =$f; if (!in_array($f,array("=","!=","<",">","<=",">=","like","LIKE"))) { throw new ExceptionInvalidFindOperator(); } } $beans = RedBean_OODB::find( $deco->getData(), $filters, $start, $end, $orderby, $extraSQL ); $decos = array(); $dclass = PRFX.$deco->type.SFFX; foreach( $beans as $bean ) { $decos[ $bean->id ] = new $dclass( floatval( $bean->id ) ); $decos[ $bean->id ]->setData( $bean ); } return $decos; } public function getIterator() { $o = new ArrayObject($this->data); return $o->getIterator(); } public function isReadOnly() { try{ RedBean_OODB::openBean($this->data, true); } catch(RedBean_Exception_FailedAccessBean $e){ return false; } return true; } }
class Redbean_Driver_PDO implements RedBean_Driver { private static $instance; private $debug = false; private $pdo; private $affected_rows; private $rs; private $exc =0; public static function getInstance($dsn, $user, $pass, $dbname) { if(is_null(self::$instance)) { self::$instance = new Redbean_Driver_PDO($dsn, $user, $pass); } return self::$instance; } public function __construct($dsn, $user, $pass) { $this->pdo = new PDO( $dsn, $user, $pass, array(PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8', PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC) ); } public function GetAll( $sql ) { $this->exc = 0; try{ if ($this->debug) { echo "<HR>" . $sql; } $rs = $this->pdo->query($sql); $this->rs = $rs; $rows = $rs->fetchAll(); if(!$rows) { $rows = array(); } if ($this->debug) { if (count($rows) > 0) { echo "<br><b style='color:green'>resultset: " . count($rows) . " rows</b>"; } } } catch(Exception $e){ $this->exc = 1; if ($this->debug){ $str = $this->Errormsg(); if ($str != "") { echo "<br><b style='color:red'>" . $str . "</b>"; } } return array(); } return $rows; } public function GetCol($sql) { $this->exc = 0; try{ $rows = $this->GetAll($sql); $cols = array(); if ($rows && is_array($rows) && count($rows)>0){ foreach ($rows as $row) { $cols[] = array_shift($row); } } } catch(Exception $e){ $this->exc = 1; return array(); } return $cols; } public function GetCell($sql) { $this->exc = 0; try{ $arr = $this->GetAll($sql); $row1 = array_shift($arr); $col1 = array_shift($row1); } catch(Exception $e){ $this->exc = 1; } return $col1; } public function GetRow($sql) { $this->exc = 0; try{ $arr = $this->GetAll($sql); } catch(Exception $e){ $this->exc = 1; return array(); } return array_shift($arr); } public function ErrorNo() { if (!$this->exc) return 0; $infos = $this->pdo->errorInfo(); return $infos[1]; } public function Errormsg() { if (!$this->exc) return ""; $infos = $this->pdo->errorInfo(); return $infos[2]; } public function Execute( $sql ) { $this->exc = 0; try{ if ($this->debug) { echo "<HR>" . $sql; } $this->affected_rows = $this->pdo->exec($sql); } catch(Exception $e){ $this->exc = 1; if ($this->debug) { $str = $this->Errormsg(); if ($str != "") { echo "<br><b style='color:red'>" . $str . "</b>"; } } return 0; } return $this->affected_rows; } public function Escape( $str ) { return substr(substr($this->pdo->quote($str), 1), 0, -1); } public function GetInsertID() { return (int) $this->pdo->lastInsertId(); } public function Affected_Rows() { return (int) $this->affected_rows; } public function setDebugMode( $tf ) { $this->debug = (bool)$tf; } public function GetRaw() { return $this->rs; } }
interface RedBean_Driver { public static function getInstance( $host, $user, $pass, $dbname ); public function GetAll( $sql ); public function GetCol( $sql ); public function GetCell( $sql ); public function GetRow( $sql ); public function ErrorNo(); public function Errormsg(); public function Execute( $sql ); public function Escape( $str ); public function GetInsertID(); public function Affected_Rows(); public function setDebugMode( $tf ); public function GetRaw(); }
class RedBean_Exception_FailedAccessBean extends Exception{}
class RedBean_Exception_InvalidArgument extends RedBean_Exception {}
class RedBean_Exception_InvalidParentChildCombination extends RedBean_Exception{}
class RedBean_Exception_Security extends RedBean_Exception {}
class RedBean_Exception_SQL extends RedBean_Exception {};
class Redbean_Exception extends Exception{}
class RedBean_Observable { private $observers = array(); public function addEventListener( $eventname, RedBean_Observer $observer ) { if (!isset($this->observers[ $eventname ])) { $this->observers[ $eventname ] = array(); } $this->observers[ $eventname ][] = $observer; } public function signal( $eventname ) { if (!isset($this->observers[ $eventname ])) { $this->observers[ $eventname ] = array(); } foreach($this->observers[$eventname] as $observer) { $observer->onEvent( $eventname, $this ); } } }
interface RedBean_Observer { public function onEvent( $eventname, RedBean_Observable $o ); }
class RedBean_OODB { private static $version = 0.5; private static $versioninf = "
		RedBean Object Database layer 
		VERSION 0.5
		BY G.J.G.T DE MOOIJ
		LICENSE BSD
		COPYRIGHT 2009
	"; private static $locktime = 10; public static $db; private static $locking = true; public static $pkey = false; private static $rollback = false; private static $me = null; private static $engine = "myisam"; private static $frozen = false; private static $writer; public function __destruct() { self::$db->exec( self::$writer->getQuery("destruct", array("engine"=>self::$engine,"rollback"=>self::$rollback)) ); RedBean_OODB::releaseAllLocks(); } public static function getVersionInfo() { return self::$versioninf; } public static function getVersionNumber() { return self::$version; } public static function setLocking( $tf ) { self::$locking = $tf; } public static function getLocking() { return self::$locking; } public static function setOptimizerActive( $bool ) { self::$optimizer = (boolean) $bool; } public static function getOptimizerActive() { return self::$optimizer; } public static function checkBean(OODBBean $bean) { foreach($bean as $prop=>$value) { $prop = preg_replace('/[^abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]/',"",$prop); if (strlen(trim($prop))===0) { throw new RedBean_Exception_Security("Invalid Characters in property"); } else { $bean->$prop = $value; } } if (!isset($bean->id)) { throw new Exception("Invalid bean, no id"); } if (!is_numeric($bean->id)) { throw new Exception("Invalid bean, id not numeric"); } if (!isset($bean->type)) { throw new Exception("Invalid bean, no type"); } if (!is_string($bean->type) || is_numeric($bean->type) || strlen($bean->type)<3) { throw new Exception("Invalid bean, wrong type"); } if ($bean->type==="locking" || $bean->type==="dtyp") { throw new Exception("Beantype is reserved table"); } if (strpos($bean->type,"_")!==false && ctype_alnum($bean->type)) { throw new Exception("Beantype contains illegal characters"); } } public static function checkBeanForAssoc( $bean ) { self::checkBean($bean); if (intval($bean->id) < 1) { $bean->id = self::set( $bean ); } return $bean; } public static function getEngine() { return self::$engine; } public static function setEngine( $engine ) { if ($engine=="myisam" || $engine=="innodb") { self::$engine = $engine; } else { throw new Exception("Unsupported database engine"); } return self::$engine; } public static function rollback() { self::$rollback = true; } public static function set( OODBBean $bean ) { self::checkBean($bean); $db = self::$db; $table = $db->escape($bean->type); if (!self::$frozen) { $tables = self::showTables(); if (!in_array($table, $tables)) { $createtableSQL = self::$writer->getQuery("create_table", array( "engine"=>self::$engine, "table"=>$table )); $db->exec( $createtableSQL ); self::addTable( $table ); } $columnsRaw = $db->get("describe `$table` "); $columns = array(); foreach($columnsRaw as $r) { $columns[$r["Field"]]=$r["Type"]; } $insertvalues = array(); $insertcolumns = array(); $updatevalues = array(); foreach( $bean as $p=>$v) { if ($p!="type" && $p!="id") { $p = $db->escape($p); $v = $db->escape($v); $typeno = self::inferType($v); if (isset($columns[$p])) { $sqlt = self::getType($columns[$p]); if ($typeno > $sqlt) { $changecolumnSQL = self::$writer->getQuery( "widen_column", array( "table" => $table, "column" => $p, "newtype" => self::$writer->typeno_sqltype[$typeno] ) ); $db->exec( $changecolumnSQL ); } } else { $addcolumnSQL = self::$writer->getQuery("add_column",array( "table"=>$table, "column"=>$p, "type"=> self::$writer->typeno_sqltype[$typeno] )); $db->exec( $addcolumnSQL ); } $insertvalues[] = $v; $insertcolumns[] = $p; $updatevalues[] = array( "property"=>$p, "value"=>$v ); } } } else { foreach( $bean as $p=>$v) { if ($p!="type" && $p!="id") { $p = $db->escape($p); $v = $db->escape($v); $insertvalues[] = $v; $insertcolumns[] = $p; $updatevalues[] = array( "property"=>$p, "value"=>$v ); } } } if ($bean->id) { self::openBean($bean, true); if (count($updatevalues)>0) { $updateSQL = self::$writer->getQuery("update", array( "table"=>$table, "updatevalues"=>$updatevalues, "id"=>$bean->id )); $db->exec( $updateSQL ); } } else { if (count($insertvalues)>0) { $insertSQL = self::$writer->getQuery("insert",array( "table"=>$table, "insertcolumns"=>$insertcolumns, "insertvalues"=>$insertvalues )); } else { $insertSQL = self::$writer->getQuery("create", array("table"=>$table)); } $db->exec( $insertSQL ); $bean->id = $db->getInsertID(); self::openBean($bean); } return $bean->id; } public static function inferType( $v ) { $db = self::$db; $rawv = $v; $checktypeSQL = self::$writer->getQuery("infertype", array( "value"=> self::$db->escape(strval($v)) )); $db->exec( $checktypeSQL ); $id = $db->getInsertID(); $readtypeSQL = self::$writer->getQuery("readtype",array( "id"=>$id )); $row=$db->getRow($readtypeSQL); $db->exec( self::$writer->getQuery("reset_dtyp") ); $tp = 0; foreach($row as $t=>$tv) { if (strval($tv) === strval($rawv)) { return $tp; } $tp++; } return $tp; } public static function getType( $sqlType ) { if (in_array($sqlType,self::$writer->sqltype_typeno)) { $typeno = self::$writer->sqltype_typeno[$sqlType]; } else { $typeno = -1; } return $typeno; } public static function init( $querywriter, $dontclose = false ) { self::$me = new RedBean_OODB(); self::$writer = $querywriter; if (self::$engine === "innodb") { self::$db->exec(self::$writer->getQuery("prepare_innodb")); self::$db->exec(self::$writer->getQuery("starttransaction")); } else if (self::$engine === "myisam"){ self::$db->exec(self::$writer->getQuery("prepare_myisam")); } if (!self::$frozen) { self::$db->exec(self::$writer->getQuery("clear_dtyp")); self::$db->exec(self::$writer->getQuery("setup_dtyp")); self::$db->exec(self::$writer->getQuery("setup_locking")); self::$db->exec(self::$writer->getQuery("setup_tables")); } if (!self::$pkey) { self::$pkey = str_replace(".","",microtime(true)."".mt_rand()); } return true; } public static function freeze() { self::$frozen = true; } public static function unfreeze() { self::$frozen = false; } public static function showTables( $all=false ) { $db = self::$db; if ($all && self::$frozen) { $alltables = $db->getCol(self::$writer->getQuery("show_tables")); return $alltables; } else { $alltables = $db->getCol(self::$writer->getQuery("show_rtables")); return $alltables; } } public static function addTable( $tablename ) { $db = self::$db; $tablename = $db->escape( $tablename ); $db->exec(self::$writer->getQuery("register_table",array("table"=>$tablename))); } public static function dropTable( $tablename ) { $db = self::$db; $tablename = $db->escape( $tablename ); $db->exec(self::$writer->getQuery("unregister_table",array("table"=>$tablename))); } public function releaseAllLocks() { self::$db->exec(self::$writer->getQuery("release",array("key"=>self::$pkey))); } public static function openBean( $bean, $mustlock=false) { self::checkBean( $bean ); if (!self::$locking || $bean->id === 0) return true; $db = self::$db; $removeExpiredSQL = self::$writer->getQuery("remove_expir_lock", array( "locktime"=>self::$locktime )); $db->exec($removeExpiredSQL); $tbl = $db->escape( $bean->type ); $id = intval( $bean->id ); $checkopenSQL = self::$writer->getQuery("get_lock",array( "id"=>$id, "table"=>$tbl, "key"=>self::$pkey )); $row = $db->getRow($checkopenSQL); if ($row && is_array($row) && count($row)>0) { $updateexpstamp = self::$writer->getQuery("update_expir_lock",array( "time"=>time(), "id"=>$row["id"] )); $db->exec($updateexpstamp); return true; } if ($mustlock) { throw new RedBean_Exception_FailedAccessBean("Could not acquire a lock for bean $tbl . $id "); return false; } $openSQL = self::$writer->getQuery("aq_lock", array( "table"=>$tbl, "id"=>$id, "key"=>self::$pkey, "time"=>time() )); $trials = 0; $aff = 0; while( $aff < 1 && $trials < 5 ) { $db->exec($openSQL); $aff = $db->getAffectedRows(); $trials++; if ($aff < 1) usleep(500000); } if ($trials > 4) { return false; } else { return true; } } private static function sync( $toggle ) { $bean = RedBean_OODB::dispense("_syncmethod"); $bean->id = 0; if ($toggle) { self::openBean( $bean ); } else { self::closeBean( $bean ); } } public static function getById($type, $id, $data=false) { $bean = self::dispense( $type ); $db = self::$db; $table = $db->escape( $type ); $id = intval( $id ); $bean->id = $id; self::openBean($bean); if (!$data) { $getSQL = self::$writer->getQuery("get_bean",array( "type"=>$type, "id"=>$id )); $row = $db->getRow( $getSQL ); } else { $row = $data; } if ($row && is_array($row) && count($row)>0) { foreach($row as $p=>$v) { $bean->$p = $v; } } else { throw new RedBean_Exception_FailedAccessBean("bean not found"); } return $bean; } public static function exists($type,$id) { $db = self::$db; $id = intval( $id ); $type = $db->escape( $type ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return false; } else { $no = $db->getCell( self::$writer->getQuery("bean_exists",array( "type"=>$type, "id"=>$id )) ); if (intval($no)) { return true; } else { return false; } } } public static function numberof($type) { $db = self::$db; $type = strtolower( $db->escape( $type ) ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return 0; } else { $no = $db->getCell( self::$writer->getQuery("count",array( "type"=>$type ))); return $no; } } static function distinct($type, $field) { $db = self::$db; $type = strtolower( $db->escape( $type ) ); $field = $db->escape( $field ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return array(); } else { $ids = $db->getCol( self::$writer->getQuery("distinct",array( "type"=>$type, "field"=>$field ))); $beans = array(); if (is_array($ids) && count($ids)>0) { foreach( $ids as $id ) { $beans[ $id ] = self::getById( $type, $id , false); } } return $beans; } } private static function stat($type,$field,$stat="sum") { $db = self::$db; $type = strtolower( $db->escape( $type ) ); $field = strtolower( $db->escape( $field ) ); $stat = $db->escape( $stat ); $alltables = self::showTables(); if (!in_array($type, $alltables)) { return 0; } else { $no = $db->getCell(self::$writer->getQuery("stat",array( "stat"=>$stat, "field"=>$field, "type"=>$type ))); return $no; } } public static function sumof($type,$field) { return self::stat( $type, $field, "sum"); } public static function avgof($type,$field) { return self::stat( $type, $field, "avg"); } public static function minof($type,$field) { return self::stat( $type, $field, "min"); } public static function maxof($type,$field) { return self::stat( $type, $field, "max"); } public static function resetAll() { $sql = self::$writer->getQuery("releaseall"); self::$db->exec( $sql ); return true; } public static function processQuerySlots($sql, $slots) { $db = self::$db; $code = sha1(rand(1,1000)*time()); foreach( $slots as $key=>$value ) { $sql = str_replace( "{".$key."}", "{".$code.$key."}" ,$sql ); } foreach( $slots as $key=>$value ) { $sql = str_replace( "{".$code.$key."}", self::$writer->getQuote().$db->escape( $value ).self::$writer->getQuote(),$sql ); } return $sql; } public static function fastLoader( $type, $ids ) { $db = self::$db; $sql = self::$writer->getQuery("fastload", array( "type"=>$type, "ids"=>$ids )); return $db->get( $sql ); } public static function getBySQL( $rawsql, $slots, $table, $max=0 ) { $db = self::$db; $sql = $rawsql; if (is_array($slots)) { $sql = self::processQuerySlots( $sql, $slots ); } $sql = str_replace('@ifexists:','', $sql); $rs = $db->getCol( self::$writer->getQuery("where",array( "table"=>$table )) . $sql ); $err = $db->getErrorMsg(); if (!self::$frozen && strpos($err,"Unknown column")!==false && $max<10) { $matches = array(); if (preg_match("/Unknown\scolumn\s'(.*?)'/",$err,$matches)) { if (count($matches)==2 && strpos($rawsql,'@ifexists')!==false){ $rawsql = str_replace('@ifexists:`'.$matches[1].'`','NULL', $rawsql); $rawsql = str_replace('@ifexists:'.$matches[1].'','NULL', $rawsql); return self::getBySQL( $rawsql, $slots, $table, ++$max); } } return array(); } else { if (is_array($rs)) { return $rs; } else { return array(); } } } public static function find(OODBBean $bean, $searchoperators = array(), $start=0, $end=100, $orderby="id ASC", $extraSQL=false) { self::checkBean( $bean ); $db = self::$db; $tbl = $db->escape( $bean->type ); $findSQL = self::$writer->getQuery("find",array( "searchoperators"=>$searchoperators, "bean"=>$bean, "start"=>$start, "end"=>$end, "orderby"=>$orderby, "extraSQL"=>$extraSQL, "tbl"=>$tbl )); $ids = $db->getCol( $findSQL ); $beans = array(); if (is_array($ids) && count($ids)>0) { foreach( $ids as $id ) { $beans[ $id ] = self::getById( $bean->type, $id , false); } } return $beans; } public static function listAll($type, $start=false, $end=false, $orderby="id ASC", $extraSQL = false) { $db = self::$db; $listSQL = self::$writer->getQuery("list",array( "type"=>$type, "start"=>$start, "end"=>$end, "orderby"=>$orderby, "extraSQL"=>$extraSQL )); return $db->get( $listSQL ); } public static function associate( OODBBean $bean1, OODBBean $bean2 ) { $db = self::$db; $bean1 = self::checkBeanForAssoc($bean1); $bean2 = self::checkBeanForAssoc($bean2); self::openBean( $bean1, true ); self::openBean( $bean2, true ); $tp1 = $bean1->type; $tp2 = $bean2->type; if ($tp1==$tp2){ $arr = array( 0=>$bean1, 1 =>$bean2 ); } else { $arr = array( $tp1=>$bean1, $tp2 =>$bean2 ); } ksort($arr); $bean1 = array_shift( $arr ); $bean2 = array_shift( $arr ); $id1 = intval($bean1->id); $id2 = intval($bean2->id); $tables = array(); array_push( $tables, $db->escape( $bean1->type ) ); array_push( $tables, $db->escape( $bean2->type ) ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); if (!self::$frozen) { $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { $t1 = $tables[0]; $t2 = $tables[1]; if ($t1==$t2) { $t2.="2"; } $assoccreateSQL = self::$writer->getQuery("create_assoc",array( "assoctable"=> $assoctable, "t1" =>$t1, "t2" =>$t2, "engine"=>self::$engine )); $db->exec( $assoccreateSQL ); $db->exec( self::$writer->getQuery("add_assoc",array( "assoctable"=> $assoctable, "t1" =>$t1, "t2" =>$t2 )) ); self::addTable( $assoctable ); } } $assocSQL = self::$writer->getQuery("add_assoc_now", array( "id1"=>$id1, "id2"=>$id2, "assoctable"=>$assoctable )); $db->exec( $assocSQL ); } public static function unassociate(OODBBean $bean1, OODBBean $bean2) { $db = self::$db; $bean1 = self::checkBeanForAssoc($bean1); $bean2 = self::checkBeanForAssoc($bean2); self::openBean( $bean1, true ); self::openBean( $bean2, true ); $idx1 = intval($bean1->id); $idx2 = intval($bean2->id); $tp1 = $bean1->type; $tp2 = $bean2->type; if ($tp1==$tp2){ $arr = array( 0=>$bean1, 1 =>$bean2 ); } else { $arr = array( $tp1=>$bean1, $tp2 =>$bean2 ); } ksort($arr); $bean1 = array_shift( $arr ); $bean2 = array_shift( $arr ); $id1 = intval($bean1->id); $id2 = intval($bean2->id); $tables = array(); array_push( $tables, $db->escape( $bean1->type ) ); array_push( $tables, $db->escape( $bean2->type ) ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); $alltables = self::showTables(); if (in_array($assoctable, $alltables)) { $t1 = $tables[0]; $t2 = $tables[1]; if ($t1==$t2) { $t2.="2"; $unassocSQL = self::$writer->getQuery("unassoc",array( "assoctable"=>$assoctable, "t1"=>$t2, "t2"=>$t1, "id1"=>$id1, "id2"=>$id2 )); $db->exec($unassocSQL); } $unassocSQL = self::$writer->getQuery("unassoc",array( "assoctable"=>$assoctable, "t1"=>$t1, "t2"=>$t2, "id1"=>$id1, "id2"=>$id2 )); $db->exec($unassocSQL); } if ($tp1==$tp2) { $assoctable2 = "pc_".$db->escape( $bean1->type )."_".$db->escape( $bean1->type ); $alltables = self::showTables(); if (in_array($assoctable2, $alltables)) { $unassocSQL = self::$writer->getQuery("untree", array( "assoctable2"=>$assoctable2, "idx1"=>$idx1, "idx2"=>$idx2 )); $db->exec($unassocSQL); } } } public static function getAssoc(OODBBean $bean, $targettype) { $db = self::$db; $bean = self::checkBeanForAssoc($bean); $id = intval($bean->id); $t1 = $db->escape( strtolower($bean->type) ); $t2 = $db->escape( $targettype ); $tables = array(); array_push( $tables, $t1 ); array_push( $tables, $t2 ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return array(); } else { if ($t1==$t2) { $t2.="2"; } $getassocSQL = self::$writer->getQuery("get_assoc",array( "t1"=>$t1, "t2"=>$t2, "assoctable"=>$assoctable, "id"=>$id )); $rows = $db->getCol( $getassocSQL ); $beans = array(); if ($rows && is_array($rows) && count($rows)>0) { foreach($rows as $i) { $beans[$i] = self::getById( $targettype, $i, false); } } return $beans; } } public static function trash( OODBBean $bean ) { self::checkBean( $bean ); if (intval($bean->id)===0) return; self::deleteAllAssoc( $bean ); self::openBean($bean); $table = self::$db->escape($bean->type); $id = intval($bean->id); self::$db->exec( self::$writer->getQuery("trash",array( "table"=>$table, "id"=>$id )) ); } public static function deleteAllAssoc( $bean ) { $db = self::$db; $bean = self::checkBeanForAssoc($bean); self::openBean( $bean, true ); $id = intval( $bean->id ); $alltables = self::showTables(); $t = $db->escape($bean->type); $checktables = array(); foreach( $alltables as $table ) { if (strpos($table,$t."_")!==false || strpos($table,"_".$t)!==false){ $checktables[] = $table; } } foreach($checktables as $table) { if (strpos($table,"pc_")===0){ $db->exec( self::$writer->getQuery("deltree",array( "id"=>$id, "table"=>$table )) ); } else { $db->exec( self::$writer->getQuery("unassoc_all_t1",array("table"=>$table,"t"=>$t,"id"=>$id)) ); $db->exec( self::$writer->getQuery("unassoc_all_t2",array("table"=>$table,"t"=>$t,"id"=>$id)) ); } } return true; } public static function deleteAllAssocType( $targettype, $bean ) { $db = self::$db; $bean = self::checkBeanForAssoc($bean); self::openBean( $bean, true ); $id = intval( $bean->id ); $t1 = $db->escape( strtolower($bean->type) ); $t2 = $db->escape( $targettype ); $tables = array(); array_push( $tables, $t1 ); array_push( $tables, $t2 ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); if (strpos($assoctable,"pc_")===0){ $db->exec( self::$writer->getQuery("deltreetype",array( "assoctable"=>$assoctable, "id"=>$id )) ); }else{ $db->exec( self::$writer->getQuery("unassoctype1",array( "assoctable"=>$assoctable, "t1"=>$t1, "id"=>$id )) ); $db->exec( self::$writer->getQuery("unassoctype2",array( "assoctable"=>$assoctable, "t1"=>$t1, "id"=>$id )) ); } return true; } public static function dispense( $type="StandardBean" ) { $oBean = new OODBBean(); $oBean->type = $type; $oBean->id = 0; return $oBean; } public static function addChild( OODBBean $parent, OODBBean $child ) { $db = self::$db; $parent = self::checkBeanForAssoc($parent); $child = self::checkBeanForAssoc($child); self::openBean( $parent, true ); self::openBean( $child, true ); if ($parent->type !== $child->type) { throw new RedBean_Exception_InvalidParentChildCombination(); } $pid = intval($parent->id); $cid = intval($child->id); $assoctable = "pc_".$db->escape($parent->type."_".$parent->type); if (!self::$frozen) { $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { $assoccreateSQL = self::$writer->getQuery("create_tree",array( "engine"=>self::$engine, "assoctable"=>$assoctable )); $db->exec( $assoccreateSQL ); $db->exec( self::$writer->getQuery("unique", array( "assoctable"=>$assoctable )) ); self::addTable( $assoctable ); } } $assocSQL = self::$writer->getQuery("add_child",array( "assoctable"=>$assoctable, "pid"=>$pid, "cid"=>$cid )); $db->exec( $assocSQL ); } public static function getChildren( OODBBean $parent ) { $db = self::$db; $parent = self::checkBeanForAssoc($parent); $pid = intval($parent->id); $assoctable = "pc_".$db->escape( $parent->type . "_" . $parent->type ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return array(); } else { $targettype = $parent->type; $getassocSQL = self::$writer->getQuery("get_children", array( "assoctable"=>$assoctable, "pid"=>$pid )); $rows = $db->getCol( $getassocSQL ); $beans = array(); if ($rows && is_array($rows) && count($rows)>0) { foreach($rows as $i) { $beans[$i] = self::getById( $targettype, $i, false); } } return $beans; } } public static function getParent( OODBBean $child ) { $db = self::$db; $child = self::checkBeanForAssoc($child); $cid = intval($child->id); $assoctable = "pc_".$db->escape( $child->type . "_" . $child->type ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return array(); } else { $targettype = $child->type; $getassocSQL = self::$writer->getQuery("get_parent", array( "assoctable"=>$assoctable, "cid"=>$cid )); $rows = $db->getCol( $getassocSQL ); $beans = array(); if ($rows && is_array($rows) && count($rows)>0) { foreach($rows as $i) { $beans[$i] = self::getById( $targettype, $i, false); } } return $beans; } } public static function removeChild(OODBBean $parent, OODBBean $child) { $db = self::$db; $parent = self::checkBeanForAssoc($parent); $child = self::checkBeanForAssoc($child); self::openBean( $parent, true ); self::openBean( $child, true ); if ($parent->type !== $child->type) { throw new RedBean_Exception_InvalidParentChildCombination(); } $assoctable = "pc_".$db->escape( $parent->type . "_" . $parent->type ); $alltables = self::showTables(); if (!in_array($assoctable, $alltables)) { return true; } else { $pid = intval($parent->id); $cid = intval($child->id); $unassocSQL = self::$writer->getQuery("remove_child", array( "assoctable"=>$assoctable, "pid"=>$pid, "cid"=>$cid )); $db->exec($unassocSQL); } } public static function numofRelated( $type, OODBBean $bean ) { $db = self::$db; $t2 = strtolower( $db->escape( $type ) ); self::checkBean( $bean ); $t1 = strtolower( $bean->type ); $tref = strtolower( $db->escape( $bean->type ) ); $id = intval( $bean->id ); $tables = array(); array_push( $tables, $t1 ); array_push( $tables, $t2 ); sort($tables); $assoctable = $db->escape( implode("_",$tables) ); $tables = self::showTables(); if ($tables && is_array($tables) && count($tables) > 0) { if (in_array( $t1, $tables ) && in_array($t2, $tables)){ $sqlCountRelations = self::$writer->getQuery( "num_related", array( "assoctable"=>$assoctable, "t1"=>$t1, "id"=>$id ) ); return (int) $db->getCell( $sqlCountRelations ); } } else { return 0; } } public static function gen( $classes ) { $classes = explode(",",$classes); foreach($classes as $c) { if ($c!=="" && $c!=="null" && !class_exists($c) && preg_match("/^\s*[A-Za-z_][A-Za-z0-9_]*\s*$/",$c)){ try{ eval("final class ".$c." extends RedBean_Decorator {
							private static \$__static_property_type = \"".strtolower($c)."\";
							
							public function __construct(\$id=0, \$lock=false) {
								parent::__construct('".strtolower($c)."',\$id,\$lock);
							}
							
							//no late static binding... great..
							public static function where( \$sql, \$slots=array() ) {
								return new RedBean_Can( self::\$__static_property_type, RedBean_OODB::getBySQL( \$sql, \$slots, self::\$__static_property_type) );
							}
	
							public static function listAll(\$start=false,\$end=false,\$orderby=' id ASC ',\$sql=false) {
								return RedBean_OODB::listAll(self::\$__static_property_type,\$start,\$end,\$orderby,\$sql);
							}
							
					}"); if (!class_exists($c)) return false; } catch(Exception $e){ return false; } } else { return false; } } return true; } public static function setLockingTime( $timeInSecs ) { if (is_int($timeInSecs) && $timeInSecs >= 0) { self::$locktime = $timeInSecs; } else { throw new RedBean_Exception_InvalidArgument( "time must be integer >= 0" ); } } public static function clean() { if (self::$frozen) { return false; } $db = self::$db; $tables = $db->getCol( self::$writer->getQuery("show_rtables") ); foreach($tables as $key=>$table) { $tables[$key] = self::$writer->getEscape().$table.self::$writer->getEscape(); } $sqlcleandatabase = self::$writer->getQuery("drop_tables",array( "tables"=>$tables )); $db->exec( $sqlcleandatabase ); $db->exec( self::$writer->getQuery("truncate_rtables") ); self::resetAll(); return true; } public static function removeUnused( ) { if (self::$frozen) { return false; } $db = self::$db; $tables = self::showTables(); foreach($tables as $table) { $classname = PRFX . $table . SFFX; if(!class_exists( $classname , true)) { $db->exec( self::$writer->getQuery("drop_tables",array("tables"=>array($table))) ); $db->exec(self::$writer->getQuery("unregister_table",array("table"=>$table))); } } } public static function dropColumn( $table, $property ) { if (self::$frozen) { return false; } $db = self::$db; $db->exec( self::$writer->getQuery("drop_column", array( "table"=>$table, "property"=>$property )) ); } public static function trashAll($type) { self::$db->exec( self::$writer->getQuery("drop_type",array("type"=>strtolower($type)))); } public static function keepInShape( $gc = false) { if (self::$frozen) { return false; } $db = self::$db; $tables = self::showTables(); if ($tables && is_array($tables) && count($tables) > 0) { if ($gc) self::removeUnused( $tables ); $table = $tables[array_rand( $tables, 1 )]; } else { return; } $table = $db->escape( $table ); if (strpos($table,'_')!==false) return; $cols = $db->get( self::$writer->getQuery("describe",array( "table"=>$table )) ); $colr = $cols[array_rand( $cols )]; $col = $db->escape( $colr["Field"] ); if ($col=="id" || strpos($col,"_id")!==false) { return; } if ($gc && !intval($db->getCell( self::$writer->getQuery("get_null",array( "table"=>$table, "col"=>$col ) )))) { $db->exec( self::$writer->getQuery("drop_column",array("table"=>$table,"property"=>$col))); return; } $currenttype = self::$writer->sqltype_typeno[$colr["Type"]]; if ($currenttype > 0) { $trytype = rand(0,$currenttype - 1); $db->exec(self::$writer->getQuery("test_column",array( "type"=>self::$writer->typeno_sqltype[$trytype], "table"=>$table ) )); $db->exec(self::$writer->getQuery("update_test",array( "table"=>$table, "col"=>$col ))); $delta = $db->getCell(self::$writer->getQuery("measure",array( "table"=>$table, "col"=>$col ))); if (intval($delta)===0) { $sql = self::$writer->getQuery("remove_test",array( "table"=>$table, "col"=>$col, "type"=>self::$writer->typeno_sqltype[$trytype] )); $db->exec($sql); } $db->exec( self::$writer->getQuery("drop_test",array( "table"=>$table )) ); } if ( strpos($colr["Type"],"TEXT")!==false || strpos($colr["Type"],"LONGTEXT")!==false ) { return; } $variance = $db->getCell(self::$writer->getQuery("variance",array( "col"=>$col, "table"=>$table ))); $records = $db->getCell(self::$writer->getQuery("count",array("table"=>$table))); if ($records) { $relvar = intval($variance) / intval($records); $indexname = "reddex_".$col; if ($records > 1 && $relvar > 0.85) { $sqladdindex=self::$writer->getQuery("index1",array( "table"=>$table, "indexname"=>$indexname, "col"=>$col )); $db->exec( $sqladdindex ); } else { $sqldropindex = self::$writer->getQuery("index2",array("table"=>$table,"indexname"=>$indexname)); $db->exec( $sqldropindex ); } } return true; } }
class OODBBean { }
class Redbean_Querylogger implements RedBean_Observer { private $path = ""; private $userid = 0; private function getFilename() { return $this->path . "audit_".date("m_d_y").".log"; } public function logSCQuery( $sql, $db ) { $sql = addslashes($sql); $line = "\n".date("H:i:s")."|".$_SERVER["REMOTE_ADDR"]."|UID=".$this->userid."|".$sql; file_put_contents( $this->getFilename(), $line, FILE_APPEND ); return null; } public static function init($path="",$userid=0) { $logger = new self; $logger->userid = $userid; $logger->path = $path; if (!file_exists($logger->getFilename())) { file_put_contents($logger->getFilename(),"begin logging"); } RedBean_OODB::$db->addEventListener( "sql_exec", $logger ); } public function onEvent( $event, RedBean_Observable $db ) { $this->logSCQuery( $db->getSQL(), $db ); } }
class QueryWriter_MySQL implements QueryWriter { public $typeno_sqltype = array( " TINYINT(3) UNSIGNED ", " INT(11) UNSIGNED ", " BIGINT(20) SIGNED ", " VARCHAR(255) ", " TEXT ", " LONGTEXT " ); public $sqltype_typeno = array( "tinyint(3) unsigned"=>0, "int(11) unsigned"=>1, "bigint(20) signed"=>2, "varchar(255)"=>3, "text"=>4, "longtext"=>5 ); public $dtypes = array( "tintyintus","intus","ints","varchar255","text","ltext" ); private function getQueryCreateTable( $options=array() ) { $engine = $options["engine"]; $table = $options["table"]; if ($engine=="myisam") { $createtableSQL = "
			 CREATE TABLE `$table` (
			`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
			 PRIMARY KEY ( `id` )
			 ) ENGINE = MYISAM 
			"; } else { $createtableSQL = "
			 CREATE TABLE `$table` (
			`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
			 PRIMARY KEY ( `id` )
			 ) ENGINE = InnoDB 
			"; } return $createtableSQL; } private function getQueryWiden( $options ) { extract($options); return "ALTER TABLE `$table` CHANGE `$column` `$column` $newtype "; } private function getQueryAddColumn( $options ) { extract($options); return "ALTER TABLE `$table` ADD `$column` $type "; } private function getQueryUpdate( $options ) { extract($options); $update = array(); foreach($updatevalues as $u) { $update[] = " `".$u["property"]."` = \"".$u["value"]."\" "; } return "UPDATE `$table` SET ".implode(",",$update)." WHERE id = ".$id; } private function getQueryInsert( $options ) { extract($options); foreach($insertcolumns as $k=>$v) { $insertcolumns[$k] = "`".$v."`"; } foreach($insertvalues as $k=>$v) { $insertvalues[$k] = "\"".$v."\""; } $insertSQL = "INSERT INTO `$table`
					  ( id, ".implode(",",$insertcolumns)." ) 
					  VALUES( null, ".implode(",",$insertvalues)." ) "; return $insertSQL; } private function getQueryCreate( $options ) { extract($options); return "INSERT INTO `$table` VALUES(null) "; } private function getQueryInferType( $options ) { extract($options); $v = "\"".$value."\""; $checktypeSQL = "insert into dtyp VALUES(null,$v,$v,$v,$v,$v )"; return $checktypeSQL; } private function getQueryResetDTYP() { return "truncate table dtyp"; } private function getQueryRegisterTable( $options ) { extract( $options ); return "replace into redbeantables values (null, \"$table\") "; } private function getQueryUnregisterTable( $options ) { extract( $options ); return "delete from redbeantables where tablename = \"$table\" "; } private function getQueryRelease( $options ) { extract( $options ); return "DELETE FROM locking WHERE fingerprint=\"".$key."\" "; } private function getQueryRemoveExpirLock( $options ) { extract( $options ); return "DELETE FROM locking WHERE expire < ".(time()-$locktime); } private function getQueryUpdateExpirLock( $options ) { extract( $options ); return "UPDATE locking SET expire=".$time." WHERE id =".$id; } private function getQueryAQLock( $options ) { extract($options); return "INSERT INTO locking VALUES(\"$table\",$id,\"".$key."\",\"".$time."\") "; } private function getQueryDistinct($options) { extract($options); return "SELECT id FROM `$type` GROUP BY $field"; } private function getQueryFastLoad( $options ) { extract( $options ); return "SELECT * FROM `$type` WHERE id IN ( ".implode(",", $ids)." ) ORDER BY FIELD(id,".implode(",", $ids).") ASC		"; } private function getQueryWhere($options) { extract($options); return "select `$table`.id from $table where "; } private function getQueryFind($options) { extract($options); $db = RedBean_OODB::$db; $findSQL = "SELECT id FROM `$tbl` WHERE "; foreach($bean as $p=>$v) { if ($p === "type" || $p === "id") continue; $p = $db->escape($p); $v = $db->escape($v); if (isset($searchoperators[$p])) { if ($searchoperators[$p]==="LIKE") { $part[] = " `$p`LIKE \"%$v%\" "; } else { $part[] = " `$p` ".$searchoperators[$p]." \"$v\" "; } } else { } } if ($extraSQL) { $findSQL .= @implode(" AND ",$part) . $extraSQL; } else { $findSQL .= @implode(" AND ",$part) . " ORDER BY $orderby LIMIT $start, $end "; } return $findSQL; } private function getQueryList($options) { extract($options); $db = RedBean_OODB::$db; if ($extraSQL) { $listSQL = "SELECT * FROM ".$db->escape($type)." ".$extraSQL; } else { $listSQL = "SELECT * FROM ".$db->escape($type)."
			ORDER BY ".$orderby; if ($end !== false && $start===false) { $listSQL .= " LIMIT ".intval($end); } if ($start !== false && $end !== false) { $listSQL .= " LIMIT ".intval($start).", ".intval($end); } if ($start !== false && $end===false) { $listSQL .= " LIMIT ".intval($start).", 18446744073709551615 "; } } return $listSQL; } private function getQueryAddAssocNow( $options ) { extract($options); return "REPLACE INTO `$assoctable` VALUES(null,$id1,$id2) "; } private function getQueryUnassoc( $options ) { extract($options); return "DELETE FROM `$assoctable` WHERE ".$t1."_id = $id1 AND ".$t2."_id = $id2 "; } private function getQueryCreateAssoc($options) { extract($options); return "
			 CREATE TABLE `$assoctable` (
			`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
			`".$t1."_id` INT( 11 ) UNSIGNED NOT NULL,
			`".$t2."_id` INT( 11 ) UNSIGNED NOT NULL,
			 PRIMARY KEY ( `id` )
			 ) ENGINE = ".$engine."; 
			"; } private function getQueryUntree( $options ) { extract($options); return "DELETE FROM `$assoctable2` WHERE
				(parent_id = $idx1 AND child_id = $idx2) OR
				(parent_id = $idx2 AND child_id = $idx1) "; } private function getQueryAddAssoc($options) { extract( $options ); return "ALTER TABLE `$assoctable` ADD UNIQUE INDEX `u_$assoctable` (`".$t1."_id`, `".$t2."_id` ) "; } private function getQueryDeltreeType($options) { extract( $options ); return "DELETE FROM $assoctable WHERE parent_id = $id  OR child_id = $id "; } private function getQueryCreateTree( $options ) { extract( $options ); return "
				 CREATE TABLE `$assoctable` (
				`id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
				`parent_id` INT( 11 ) UNSIGNED NOT NULL,
				`child_id` INT( 11 ) UNSIGNED NOT NULL,
				 PRIMARY KEY ( `id` )
				 ) ENGINE = ".$engine."; 
				"; } private function getQueryUnique( $options ) { extract( $options ); return "ALTER TABLE `$assoctable` ADD UNIQUE INDEX `u_$assoctable` (`parent_id`, `child_id` ) "; } private function getQueryAddChild( $options ) { extract( $options ); return "REPLACE INTO `$assoctable` VALUES(null,$pid,$cid) "; } private function getQueryRemoveChild( $options ) { extract( $options ); return "DELETE FROM `$assoctable` WHERE
				( parent_id = $pid AND child_id = $cid ) "; } private function getQueryDescribe( $options ) { extract( $options ); return "describe `$table`"; } private function getQueryDropTables( $options ) { extract($options); return "drop tables ".implode(",",$tables); } private function getQueryDropColumn( $options ) { extract($options); return "ALTER TABLE `$table` DROP `$property`"; } private function getQueryTestColumn( $options ) { extract($options); return "alter table `$table` add __test  ".$type; } private function getQueryUpdateTest( $options ) { extract($options); return "update `$table` set __test=`$col`"; } private function getQueryMeasure( $options ) { extract($options); return "select count(*) as df from `$table` where
				strcmp(`$col`,__test) != 0 AND `$col` IS NOT NULL"; } private function getQueryRemoveTest($options) { extract($options); return "alter table `$table` change `$col` `$col` ".$type; } private function getQueryDropTest($options) { extract($options); return "alter table `$table` drop __test"; } private function getIndex1($options) { extract($options); return "ALTER IGNORE TABLE `$table` ADD INDEX $indexname (`$col`)"; } private function getIndex2($options) { extract($options); return "ALTER IGNORE TABLE `$table` DROP INDEX $indexname"; } private function getDestruct($options) { extract($options); if ($rollback) return; if ($engine=="innodb") return "COMMIT"; else return ""; } private function getBasicQuery( $options, $sql_type="SELECT" ) { extract($options); if (isset($fields)){ $sqlfields = array(); foreach($fields as $field) { $sqlfields[] = " `$field` "; } $field = implode(",", $fields); } if (!isset($field)) $field=""; $sql = "$sql_type ".$field." FROM `$table` "; if (isset($where)) { if (is_array($where)) { $crit = array(); foreach($where as $w=>$v) { $crit[] = " `$w` = \"".$v."\""; } $sql .= " WHERE ".implode(" AND ",$crit); } else { $sql .= " WHERE ".$where; } } return $sql; } public function getQuery( $queryname, $params=array() ) { switch($queryname) { case "create_table": return $this->getQueryCreateTable($params); break; case "widen_column": return $this->getQueryWiden($params); break; case "add_column": return $this->getQueryAddColumn($params); break; case "update": return $this->getQueryUpdate($params); break; case "insert": return $this->getQueryInsert($params); break; case "create": return $this->getQueryCreate($params); break; case "infertype": return $this->getQueryInferType($params); break; case "readtype": return $this->getBasicQuery( array("fields"=>array("tinyintus","intus","ints","varchar255","text"), "table" =>"dtyp", "where"=>array("id"=>$params["id"]))); break; case "reset_dtyp": return $this->getQueryResetDTYP(); break; case "prepare_innodb": return "SET autocommit=0"; break; case "prepare_myisam": return "SET autocommit=1"; break; case "starttransaction": return "START TRANSACTION"; break; case "setup_dtyp": return "
				CREATE TABLE IF NOT EXISTS `dtyp` (
				  `id` int(11) unsigned NOT NULL auto_increment,
				  `tinyintus` tinyint(3) unsigned NOT NULL,
				  `intus` int(11) unsigned NOT NULL,
				  `ints` bigint(20) NOT NULL,
				  
				  `varchar255` varchar(255) NOT NULL,
				  `text` text NOT NULL,
				  PRIMARY KEY  (`id`)
				) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
				"; break; case "clear_dtyp": return "drop tables dtyp"; break; case "setup_locking": return "
				CREATE TABLE IF NOT EXISTS `locking` (
				  `tbl` varchar(255) NOT NULL,
				  `id` bigint(20) NOT NULL,
				  `fingerprint` varchar(255) NOT NULL,
				  `expire` int(11) NOT NULL,
				  UNIQUE KEY `tbl` (`tbl`,`id`)
				) ENGINE=MyISAM DEFAULT CHARSET=latin1;
				"; break; case "setup_tables": return "
				 CREATE TABLE IF NOT EXISTS `redbeantables` (
				 `id` INT( 11 ) UNSIGNED NOT NULL AUTO_INCREMENT ,
				 `tablename` VARCHAR( 255 ) NOT NULL ,
				 PRIMARY KEY ( `id` ),
				 UNIQUE KEY `tablename` (`tablename`)
				 ) ENGINE = MYISAM 
				"; break; case "show_tables": return "show tables"; break; case "show_rtables": return "select tablename from redbeantables"; break; case "register_table": return $this->getQueryRegisterTable( $params ); break; case "unregister_table": return $this->getQueryUnregisterTable( $params ); break; case "release": return $this->getQueryRelease( $params ); break; case "remove_expir_lock": return $this->getQueryRemoveExpirLock( $params ); break; case "update_expir_lock": return $this->getQueryUpdateExpirLock( $params ); break; case "aq_lock": return $this->getQueryAQLock( $params ); break; case "get_lock": return $this->getBasicQuery(array("fields"=>array("id"),"table"=>"locking","where"=>array("id"=>$params["id"],"tbl"=>$params["table"],"fingerprint"=>$params["key"]))); break; case "get_bean": return $this->getBasicQuery(array("field"=>"*","table"=>$params["type"],"where"=>array("id"=>$params["id"]))); break; case "bean_exists": return $this->getBasicQuery(array("field"=>"count(*)","table"=>$params["type"],"where"=>array("id"=>$params["id"]))); break; case "count": return $this->getBasicQuery(array("field"=>"count(*)","table"=>$params["type"])); break; case "distinct": return $this->getQueryDistinct($params); break; case "stat": return $this->getBasicQuery(array("field"=>$params["stat"]."(`".$params["field"]."`)","table"=>$params["type"])); break; case "releaseall": return "TRUNCATE locking"; break; case "fastload": return $this->getQueryFastLoad($params); break; case "where": return $this->getQueryWhere($params); break; case "find": return $this->getQueryFind( $params); break; case "list": return $this->getQueryList( $params); break; case "create_assoc": return $this->getQueryCreateAssoc( $params ); break; case "add_assoc": return $this->getQueryAddAssoc( $params ); break; case "add_assoc_now": return $this->getQueryAddAssocNow( $params ); break; case "unassoc": return $this->getQueryUnassoc( $params ); break; case "untree": return $this->getQueryUntree( $params ); break; case "get_assoc": $col = $params["t1"]."_id"; return $this->getBasicQuery(array( "table"=>$params["assoctable"], "fields"=>array( $params["t2"]."_id" ), "where"=>array( $col=>$params["id"]) )); break; case "trash": return $this->getBasicQuery(array("table"=>$params["table"],"where"=>array("id"=>$params["id"])),"DELETE"); break; case "deltree": return $this->getBasicQuery(array("table"=>$params["table"],"where"=>" parent_id = ".$params["id"]." OR child_id = ".$params["id"]),"DELETE"); break; case "unassoc_all_t1": $col = $params["t"]."_id"; return $this->getBasicQuery(array("table"=>$params["table"],"where"=>array($col=>$params["id"])),"DELETE"); break; case "unassoc_all_t2": $col = $params["t"]."2_id"; return $this->getBasicQuery(array("table"=>$params["table"],"where"=>array($col=>$params["id"])),"DELETE"); break; case "deltreetype": return $this->getQueryDeltreeType( $params ); break; case "unassoctype1": $col = $params["t1"]."_id"; $r = $this->getBasicQuery(array("table"=>$params["assoctable"],"where"=>array($col=>$params["id"])),"DELETE"); return $r; break; case "unassoctype2": $col = $params["t1"]."2_id"; $r =$this->getBasicQuery(array("table"=>$params["assoctable"],"where"=>array($col=>$params["id"])),"DELETE"); return $r; break; case "create_tree": return $this->getQueryCreateTree( $params ); break; case "unique": return $this->getQueryUnique( $params ); break; case "add_child": return $this->getQueryAddChild( $params ); break; case "get_children": return $this->getBasicQuery(array("table"=>$params["assoctable"],"fields"=>array("child_id"), "where"=>array("parent_id"=>$params["pid"]))); break; case "get_parent": return $this->getBasicQuery(array( "where"=>array("child_id"=>$params["cid"]),"fields"=>array("parent_id"),"table"=>$params["assoctable"] )); break; case "remove_child": return $this->getQueryRemoveChild( $params ); break; case "num_related": $col = $params["t1"]."_id"; return $this->getBasicQuery(array("field"=>"COUNT(1)","table"=>$params["assoctable"],"where"=>array($col=>$params["id"]))); break; case "drop_tables": return $this->getQueryDropTables( $params ); break; case "truncate_rtables": return "truncate redbeantables"; break; case "drop_column": return $this->getQueryDropColumn( $params ); break; case "describe": return $this->getQueryDescribe( $params ); break; case "get_null": return $this->getBasicQuery(array("field"=>"count(*)","table"=>$params["table"],"where"=>" `".$params["col"]."` IS NOT NULL ")); return $this->getQueryGetNull( $params ); break; case "test_column": return $this->getQueryTestColumn( $params ); break; case "update_test": return $this->getQueryUpdateTest( $params ); break; case "measure": return $this->getQueryMeasure( $params ); break; case "remove_test": return $this->getQueryRemoveTest($params); break; case "drop_test": return $this->getQueryDropTest($params); break; case "variance": return $this->getBasicQuery(array("field"=>"count(distinct `".$params["col"]."`)","table"=>$params["table"])); break; case "index1": return $this->getIndex1($params); break; case "index2": return $this->getIndex2($params); break; case "drop_type": return $this->getBasicQuery(array("table"=>$params["type"]),"DELETE"); break; case "destruct": return $this->getDestruct($params); break; default: throw new Exception("QueryWriter has no support for Query:".$queryname); } } public function getQuote() { return "\""; } public function getEscape() { return "`"; } }
interface QueryWriter { public function getQuery( $queryname, $params=array() ); public function getQuote(); public function getEscape(); }
if (!isset($db)) define("PRFX",""); if (!isset($db)) define("SFFX",""); class RedBean_Setup { public static function kickstart( $dsn="mysql:host=localhost;dbname=oodb", $username='root', $password='', $freeze=false, $engine="innodb", $debugmode=false, $unlockall=false ) { eval("
			class R extends RedBean_OODB { }
		"); eval("
			class RD extends RedBean_Decorator { }
		"); $db = Redbean_Driver_PDO::getInstance( $dsn, $username, $password, null ); if ($debugmode) { $db->setDebugMode(1); } RedBean_OODB::$db = new RedBean_DBAdapter($db); RedBean_OODB::setEngine($engine); RedBean_OODB::init( new QueryWriter_MySQL() ); if ($unlockall) { RedBean_OODB::resetAll(); } if ($freeze) { RedBean_OODB::freeze(); } } public static function kickstartDev( $gen, $dsn, $username="root", $password="" ) { self::kickstart( $dsn, $username, $password, false, "innodb", false, false); R::gen( $gen ); } public static function kickstartFrozen( $gen, $dsn, $username="root", $password="" ) { self::kickstart( $dsn, $username, $password, true, "innodb", false, false); R::gen( $gen ); } }
class RedBean_Sieve { private $vals; private $report = array(); private $succes = true; public static function make( $validations ) { $sieve = new self; $sieve->vals = $validations; return $sieve; } public function valid( RedBean_Decorator $deco ) { foreach($this->vals as $p => $v) { if (class_exists($v)) { $validator = new $v( $deco, $report ); if ($validator instanceof RedBean_Validator) { $message = $validator->check( $deco->$p ); if ($message !== true) { $this->succes = false; } if (!is_array($this->report[$v])) { $this->report[$v]=array(); } $this->report[ $v ][ $p ] = $message; } } } return $this->succes; } public function validAndReport( RedBean_Decorator $deco, $key=false ) { $this->valid( $deco ); if ($key) { if (isset($this->report[$key])) { return $this->report[$key]; } } return $this->report; } public function getReport() { return $this->report; } }
class RedBean_Tools { private static $class_definitions; private static $remove_whitespaces; public static function walk_dir( $root, $callback, $recursive = true ) { $root = realpath($root); $dh = @opendir( $root ); if( false === $dh ) { return false; } while(false !== ($file = readdir($dh))) { if( "." == $file || ".." == $file ) { continue; } call_user_func( $callback, "{$root}/{$file}" ); if( false !== $recursive && is_dir( "{$root}/{$file}" )) { Redbean_Tools::walk_dir( "{$root}/{$file}", $callback, $recursive ); } } closedir($dh); return true; } public static function compile($file = '', $removeWhiteSpaces = true) { self::$remove_whitespaces = $removeWhiteSpaces; self::$class_definitions = ''; $base = dirname(__FILE__) . '/'; self::walk_dir($base,'Redbean_Tools::stripClassDefinition'); $content = str_replace("\r\n","\n", ' ' . "\n" . file_get_contents($base . 'license.txt') . "\n" . self::$class_definitions); if(!empty($file)) { file_put_contents($file, $content); } return $content; } private static function stripClassDefinition($file) { if(is_file($file) && substr($file, -4) == '.php') { if(self::$remove_whitespaces) { self::$class_definitions .= "\n" . trim(str_replace('', '', php_strip_whitespace($file))); } else { self::$class_definitions .= "\n" . trim(str_replace('', '', trim(file_get_contents($file)))); } } } }
class RedBean_Validator_AlphaNumeric implements RedBean_Validator { public function check( $v ) { return (bool) preg_match('/^[A-Za-z0-9]+$/', $v); } }
interface RedBean_Validator { public function check( $property ); }